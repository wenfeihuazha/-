# 关于微任务宏任务简单练习

## 问题

```js
console.log('A');
setTimeout(() => console.log('B'), 1000);
const start = new Date();
while (new Date() - start < 3000) {}
console.log('C');
setTimeout(() => console.log('D'), 0);
new Promise((resolve, reject) => {
  console.log('E');
  foo.bar(100);
})
  .then(() => console.log('F'))
  .then(() => console.log('G'))
  .catch(() => console.log('H'));
console.log('I');
```

<!-- ![问题](./images/20200915_1.jpeg) -->

## 思路

- 第一行 输出 A

- 第二行 为异步 所有 setTimeout 为宏任务，假设为 t1 线程放后处理

- 第四行 while 函数阻塞主线程 3s （此时 t1 设置的时间已经过去但主线程未结束 所以 t1 仍在排队

- 第五行 输出 C

- 第六行 setTimeout 也是宏任务 假设为 t2 0 秒为在主线程后立即执行 但是此时应仍然排在 t1 后

- 第七行 new Promise 为同步任务 内部会先执行 输出 E <br/>
  but 没有声明 foo.bar 所以会进入 catch（ catch then 为微任务 在主线程完成后 不管之前排了多少个宏任务，等待了多久都直接执行

- 第十一十二行不会输出 因为没有 resolve 函数调用

- 第十四行 输出 I 此后进入 微任务（ 输出 H ) -> 在进入 t1 -> 再进入 t2

## 答案

A -> C -> E -> I -> H -> B -> D

## 总结

> js 为单线程,执行顺序为先主线程 -> 主线程中的微任务 -> 其他宏任务

> new Promise 为同步任务,内部优先执行

> while 回阻塞主线程. 在阻塞时 setTimeout 函数计时仍在继续,但是无法执行

## 拓展

```js
console.log(1);
setTimeout(() => {
  console.log(2);
  new Promise((resolve) => {
    console.log(3);
    setTimeout(() => console.log(4), 0); 
    for (let i = 1; i < 1000; i++) {
      resolve();
    }
    console.log(5);
  }).then(() => {
    setTimeout(() => console.log(12), 0); 
    console.log(11);
  });
  console.log(6);
  setTimeout(() => {
    console.log(7); 
  }, 0);
}, 0);

Promise.resolve().then(() => {
  console.log(8);
});

setTimeout(
  (() => {
    console.log(10);
  })(),
  0
);
```
