# 原型链 && new 关键字

## 问题

```js
function Foo(){
  getName = function(){
    console.log(1)
  }
  return this;
}
Foo.getName = function(){
  console.log(2);
}
Foo.prototype.getName = function(){
  console.log(3)
}
var getName = function(){
  console.log(4)
};
function getName(){
  console.log(5)
}

Foo.getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();
```

## 答案

```js
2 -> 1 -> 1 -> 2 -> 3 -> 3
```

## 思路

> 第一步直接调用Foo的静态方法,所以打印2

> 第二步调用函数内部中的getName 所以打印1

> 第三步在执行过Foo().getName()的基础上,getName被重新赋值,所以为1.
>> 如果未执行Foo().getName() 结果为4

> 第四步构造器私有属性 所以为2 

> 第五步 原型上的getName 打印3

> 第六步 首先new Foo()得到一个空对象{} <br/>
向空对象中添加一个属性getName,值为一个函数 <br/>
new {}.getName() 等价于
var bar new (new Foo().getName());console.log(bar) <br/>
先new Foo得到的实例对象上的getName方法,再将这个原型上getName方法当做构造函数继续new 所以执行原型上的方法 打印 3

## 拓展

在博客中查看手写new 