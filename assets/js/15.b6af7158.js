(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{360:function(a,t,r){"use strict";r.r(t);var s=r(42),e=Object(s.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"js-异步解决方案的发展历程以及优缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#js-异步解决方案的发展历程以及优缺点"}},[a._v("#")]),a._v(" JS 异步解决方案的发展历程以及优缺点")]),a._v(" "),r("h2",{attrs:{id:"回调函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#回调函数"}},[a._v("#")]),a._v(" 回调函数")]),a._v(" "),r("h3",{attrs:{id:"缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),r("p",[a._v("回调地狱,不能用try catch 捕获错误,不能return; "),r("br"),a._v("\n回调地狱的根本问题在于")]),a._v(" "),r("ul",[r("li",[a._v("缺乏顺序性:回调地狱导致的调试困难,和大脑思维方式不服")]),a._v(" "),r("li",[a._v("嵌套函数存在耦合性,一旦有所改动,就会牵一发而动全身,(即控制反转)")]),a._v(" "),r("li",[a._v("嵌套函数过多的话,很难处理错误")])]),a._v(" "),r("h3",{attrs:{id:"优点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),r("p",[a._v("解决了同步的问题(只要有一个任务耗时很长,后面的任务都必须排队等着,会拖延整个程序的执行)")]),a._v(" "),r("h2",{attrs:{id:"promise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[a._v("#")]),a._v(" Promise")]),a._v(" "),r("p",[a._v("Promise 就是为了解决 callback 的问题而产生的 "),r("br"),a._v("\nPromise 实现了链式调用,也就是说每次then后返回的都是一个全新的 Promise , 如果我们在 then 中 return, return 的结果会被Promise.resolve()包装")]),a._v(" "),r("h3",{attrs:{id:"优点-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优点-2"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),r("p",[a._v("解决了回调地狱的问题")]),a._v(" "),r("h3",{attrs:{id:"缺点-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),r("p",[a._v("无法取消Promise,错误需要通过回调函数来捕获")]),a._v(" "),r("h2",{attrs:{id:"generator"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#generator"}},[a._v("#")]),a._v(" Generator")]),a._v(" "),r("p",[a._v("特点: 可以控制函数的执行,可以配合co函数库使用")]),a._v(" "),r("h2",{attrs:{id:"async-await"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#async-await"}},[a._v("#")]),a._v(" async/await")]),a._v(" "),r("p",[a._v("async,await 是异步的终极解决方案")]),a._v(" "),r("h3",{attrs:{id:"优点-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优点-3"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),r("p",[a._v("代码清晰,不用想Promise写一大堆 then 链,处理了回调地狱的问题")]),a._v(" "),r("h3",{attrs:{id:"缺点-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点-3"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),r("p",[a._v("await 将异步代码改造为同步代码,如果多个异步操作没有依赖性而使用 await 会导致性能上的降低")])])}),[],!1,null,null,null);t.default=e.exports}}]);